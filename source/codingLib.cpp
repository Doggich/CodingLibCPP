#include <iostream>
#include <fstream>
#include <map>

#ifdef _WIN32
    #define EXPORT __declspec(dllexport)
#else
    #define EXPORT
#endif

std::string decode(std::string encode_str){

    const std::map<std::string, std::string> decode_codes = {
        {"00000000", "a"},
        {"00000001", "b"},
        {"00000010", "c"},
        {"00000011", "d"},
        {"00000100", "e"},
        {"00000101", "f"},
        {"00000110", "g"},
        {"00000111", "h"},
        {"00001000", "i"},
        {"00001001", "j"},
        {"00001010", "k"},
        {"00001011", "l"},
        {"00001100", "m"},
        {"00001101", "n"},
        {"00001110", "o"},
        {"00001111", "p"},
        {"00010000", "q"},
        {"00010001", "r"},
        {"00010010", "s"},
        {"00010011", "t"},
        {"00010100", "u"},
        {"00010101", "v"},
        {"00010110", "w"},
        {"00010111", "x"},
        {"00011000", "y"},
        {"00011001", "z"},
        {"00011010", "A"},
        {"00011011", "B"},
        {"00011100", "C"},
        {"00011101", "D"},
        {"00011110", "E"},
        {"00011111", "F"},
        {"00100000", "G"},
        {"00100001", "H"},
        {"00100010", "I"},
        {"00100011", "J"},
        {"00100100", "K"},
        {"00100101", "L"},
        {"00100110", "M"},
        {"00100111", "N"},
        {"00101000", "O"},
        {"00101001", "P"},
        {"00101010", "Q"},
        {"00101011", "R"},
        {"00101100", "S"},
        {"00101101", "T"},
        {"00101110", "U"},
        {"00101111", "V"},
        {"00110000", "W"},
        {"00110001", "X"},
        {"00110010", "Y"},
        {"00110011", "Z"},
        {"00110100", "0"},
        {"00110101", "1"},
        {"00110110", "2"},
        {"00110111", "3"},
        {"00111000", "4"},
        {"00111001", "5"},
        {"00111010", "6"},
        {"00111011", "7"},
        {"00111100", "8"},
        {"00111101", "9"},
        {"00111110", " "},
        {"00111111", ","},
        {"01000000", "."},
        {"01000001", "("},
        {"01000010", ")"},
        {"01000011", "{"},
        {"01000100", "}"},
        {"01000101", "["},
        {"01000110", "]"},
        {"01000111", "-"},
        {"01001000", "="},
        {"01001001", "_"},
        {"01001010", "+"},
        {"01001011", "<"},
        {"01001100", ">"},
        {"01001101", "/"},
        {"01001110", "|"},
        {"01001111", "\\"},
        {"01010000", "?"},
        {"01010001", "!"},
        {"01010010", "\t"},
        {"01010011", "\n"}
    };

    unsigned long long int count_words = encode_str.size() / 8;

    std::string result = "";

    for (unsigned long long i = 0; i < count_words; i++) {
        std::string key = encode_str.substr(i * 8, 8);
        auto tmp = decode_codes.find(key);
        
        if (tmp != decode_codes.end()) {
            result += tmp->second;
        } else {
            result += "?";
        }
    }
    
    return result;

}

std::string encode(std::string decode_str) {

    const std::map<char, std::string> encode_codes = {
        {'a', "00000000"},
        {'b', "00000001"},
        {'c', "00000010"},
        {'d', "00000011"},
        {'e', "00000100"},
        {'f', "00000101"},
        {'g', "00000110"},
        {'h', "00000111"},
        {'i', "00001000"},
        {'j', "00001001"},
        {'k', "00001010"},
        {'l', "00001011"},
        {'m', "00001100"},
        {'n', "00001101"},
        {'o', "00001110"},
        {'p', "00001111"},
        {'q', "00010000"},
        {'r', "00010001"},
        {'s', "00010010"},
        {'t', "00010011"},
        {'u', "00010100"},
        {'v', "00010101"},
        {'w', "00010110"},
        {'x', "00010111"},
        {'y', "00011000"},
        {'z', "00011001"},
        {'A', "00011010"},
        {'B', "00011011"},
        {'C', "00011100"},
        {'D', "00011101"},
        {'E', "00011110"},
        {'F', "00011111"},
        {'G', "00100000"},
        {'H', "00100001"},
        {'I', "00100010"},
        {'J', "00100011"},
        {'K', "00100100"},
        {'L', "00100101"},
        {'M', "00100110"},
        {'N', "00100111"},
        {'O', "00101000"},
        {'P', "00101001"},
        {'Q', "00101010"},
        {'R', "00101011"},
        {'S', "00101100"},
        {'T', "00101101"},
        {'U', "00101110"},
        {'V', "00101111"},
        {'W', "00110000"},
        {'X', "00110001"},
        {'Y', "00110010"},
        {'Z', "00110011"},
        {'0', "00110100"},
        {'1', "00110101"},
        {'2', "00110110"},
        {'3', "00110111"},
        {'4', "00111000"},
        {'5', "00111001"},
        {'6', "00111010"},
        {'7', "00111011"},
        {'8', "00111100"},
        {'9', "00111101"},
        {' ', "00111110"},
        {',', "00111111"},
        {'.', "01000000"},
        {'(', "01000001"},
        {')', "01000010"},
        {'{', "01000011"},
        {'}', "01000100"},
        {'[', "01000101"},
        {']', "01000110"},
        {'-', "01000111"},
        {'=', "01001000"},
        {'_', "01001001"},
        {'+', "01001010"},
        {'<', "01001011"},
        {'>', "01001100"},
        {'/', "01001101"},
        {'|', "01001110"},
        {'\\', "01001111"},
        {'?', "01010000"},
        {'!', "01010001"},
        {'\t', "01010010"},
        {'\n', "01010011"}
    };

    std::string result = "";

    for(char c : decode_str) {
        auto it = encode_codes.find(c);
        if (it != encode_codes.end()) {
            result += it->second;
        } else {
            throw std::runtime_error("Char '" + std::string(1, c) + "' not found!");
        }
    }

    return result;
}

extern "C" EXPORT const char* encode_string(const char* input) {
    static std::string result;
    try {
        result = encode(std::string(input));
        return result.c_str();
    } catch(...) {
        result = "ERROR";
        return result.c_str();
    }
}

extern "C" EXPORT const char* decode_string(const char* input) {
    static std::string result;
    try {
        result = decode(std::string(input));
        return result.c_str();
    } catch(...) {
        result = "ERROR";
        return result.c_str();
    }
}
